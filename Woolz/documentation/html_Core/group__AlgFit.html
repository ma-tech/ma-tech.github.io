<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Woolz Image Processing: AlgFit</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Woolz Image Processing
   &#160;<span id="projectnumber">Version 1.8.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__AlgFit.html','');});
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">AlgFit</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:AlgBSpline_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AlgBSpline_8c.html">AlgBSpline.c</a></td></tr>
<tr class="memdesc:AlgBSpline_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides functions for fitting and evaluating B-Splines. This software is based on netlib Dierckx Fortran subroutines. In most cases the original comments have been preserved with little change and are inculded in the Doxygen documentation verbatim. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:AlgLinearFit_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AlgLinearFit_8c.html">AlgLinearFit.c</a></td></tr>
<tr class="memdesc:AlgLinearFit_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides functions for fitting linear models to data, ie linear regression. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:AlgPolyLSQ_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AlgPolyLSQ_8c.html">AlgPolyLSQ.c</a></td></tr>
<tr class="memdesc:AlgPolyLSQ_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides functions for fitting a polynomial using least squares. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6e92d82a9e57b56a1f9e4e830953d762"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AlgFit.html#ga6e92d82a9e57b56a1f9e4e830953d762">AlgBSplineBspl</a> (double *t, int k, double x, int l, double *h)</td></tr>
<tr class="memdesc:ga6e92d82a9e57b56a1f9e4e830953d762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the (k+1) non-zero B-Splines of degree k at t[l] using the de Boor Cox recurrence.  <a href="#ga6e92d82a9e57b56a1f9e4e830953d762">More...</a><br /></td></tr>
<tr class="separator:ga6e92d82a9e57b56a1f9e4e830953d762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39fcbe5976c8836909cee34bba5efea3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="AlgType_8h.html#aef11f3ce7e5ac4471a5d3359996838c0">AlgError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AlgFit.html#ga39fcbe5976c8836909cee34bba5efea3">AlgBSplineNDFit</a> (int iopt, int ipar, int idim, int m, double *u, int mx, double *x, double *w, double ub, double ue, int k, double s, int nest, int *n, double *t, int *nc, double *c, double *fp, double *wrk, int *iwrk)</td></tr>
<tr class="memdesc:ga39fcbe5976c8836909cee34bba5efea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a smooth approximating b-spline in multi-dimensional space.  <a href="#ga39fcbe5976c8836909cee34bba5efea3">More...</a><br /></td></tr>
<tr class="separator:ga39fcbe5976c8836909cee34bba5efea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga900b986ff7f6be5385dd1f5c51abc4f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="AlgType_8h.html#aef11f3ce7e5ac4471a5d3359996838c0">AlgError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AlgFit.html#ga900b986ff7f6be5385dd1f5c51abc4f0">AlgBSplinePerFit</a> (int iopt, int m, double *x, double *y, double *w, int k, double s, int nest, int *n, double *t, double *c, double *fp, double *wrk, int *iwrk)</td></tr>
<tr class="memdesc:ga900b986ff7f6be5385dd1f5c51abc4f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a smooth periodic B-spline approximation through the given data.  <a href="#ga900b986ff7f6be5385dd1f5c51abc4f0">More...</a><br /></td></tr>
<tr class="separator:ga900b986ff7f6be5385dd1f5c51abc4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad759d14c2f79746e3612145520ec919"><td class="memItemLeft" align="right" valign="top"><a class="el" href="AlgType_8h.html#aef11f3ce7e5ac4471a5d3359996838c0">AlgError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AlgFit.html#gaad759d14c2f79746e3612145520ec919">AlgBSplineFit</a> (int iopt, int m, double *x, double *y, double *w, double xb, double xe, int k, double s, int nest, int *n, double *t, double *c, double *fp, double *wrk, int *iwrk)</td></tr>
<tr class="memdesc:gaad759d14c2f79746e3612145520ec919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a smooth B-spline approximation through the given data.  <a href="#gaad759d14c2f79746e3612145520ec919">More...</a><br /></td></tr>
<tr class="separator:gaad759d14c2f79746e3612145520ec919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga509bd266ecdf5ca999f8a99d9665a90e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="AlgType_8h.html#aef11f3ce7e5ac4471a5d3359996838c0">AlgError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AlgFit.html#ga509bd266ecdf5ca999f8a99d9665a90e">AlgBSplineEval</a> (double *t, int n, double *c, int k, double *x, double *y, int m)</td></tr>
<tr class="memdesc:ga509bd266ecdf5ca999f8a99d9665a90e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a b-spline at a number of points.  <a href="#ga509bd266ecdf5ca999f8a99d9665a90e">More...</a><br /></td></tr>
<tr class="separator:ga509bd266ecdf5ca999f8a99d9665a90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f5ba44db195ed6f2c3d44468bf6235e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="AlgType_8h.html#aef11f3ce7e5ac4471a5d3359996838c0">AlgError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AlgFit.html#ga0f5ba44db195ed6f2c3d44468bf6235e">AlgBSplineDer</a> (double *t, int n, double *c, int k, int nu, double *x, double *y, int m, double *wrk)</td></tr>
<tr class="memdesc:ga0f5ba44db195ed6f2c3d44468bf6235e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the derivatives of order nu of the B-spline of degree k.  <a href="#ga0f5ba44db195ed6f2c3d44468bf6235e">More...</a><br /></td></tr>
<tr class="separator:ga0f5ba44db195ed6f2c3d44468bf6235e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25da23481eb7b8d9c18b8c037b6fbd2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="AlgType_8h.html#aef11f3ce7e5ac4471a5d3359996838c0">AlgError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AlgFit.html#ga25da23481eb7b8d9c18b8c037b6fbd2e">AlgLinearFit1D</a> (int datSz, double *datXA, double *datYA, double *dstA, double *dstB, double *dstSigA, double *dstSigB, double *dstQ)</td></tr>
<tr class="memdesc:ga25da23481eb7b8d9c18b8c037b6fbd2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the least squares best fit straight line (y = a + bx) through the given data, ie linear regression. This function is based on the function fit(): Press W. H., Teukolsky S. A., Vetterling W. T. and Flannery B. P, Numerical Recipies in C, 1992, CUP.  <a href="#ga25da23481eb7b8d9c18b8c037b6fbd2e">More...</a><br /></td></tr>
<tr class="separator:ga25da23481eb7b8d9c18b8c037b6fbd2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6b612137729b7de26175d64530b3dbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="AlgType_8h.html#aef11f3ce7e5ac4471a5d3359996838c0">AlgError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AlgFit.html#gaf6b612137729b7de26175d64530b3dbe">AlgLinearFitIdx1D</a> (double *datXA, double *datYA, int *idxXA, int *idxYA, int idxASz, double *dstA, double *dstB, double *dstSigA, double *dstSigB, double *dstQ)</td></tr>
<tr class="memdesc:gaf6b612137729b7de26175d64530b3dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the least squares best fit straight line (y = a + bx) through the given data, ie linear regression.  <a href="#gaf6b612137729b7de26175d64530b3dbe">More...</a><br /></td></tr>
<tr class="separator:gaf6b612137729b7de26175d64530b3dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0621eeda942143f5e7bbec25f63fd38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="AlgType_8h.html#aef11f3ce7e5ac4471a5d3359996838c0">AlgError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AlgFit.html#gaa0621eeda942143f5e7bbec25f63fd38">AlgPolynomialLSq</a> (double *xVec, double *yVec, int vecSz, int polyDeg, double *cVec)</td></tr>
<tr class="memdesc:gaa0621eeda942143f5e7bbec25f63fd38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to fit a polynomial to the given data using a least squares approach.  <a href="#gaa0621eeda942143f5e7bbec25f63fd38">More...</a><br /></td></tr>
<tr class="separator:gaa0621eeda942143f5e7bbec25f63fd38"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga6e92d82a9e57b56a1f9e4e830953d762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e92d82a9e57b56a1f9e4e830953d762">&#9670;&nbsp;</a></span>AlgBSplineBspl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AlgBSplineBspl </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the (k+1) non-zero B-Splines of degree k at t[l] using the de Boor Cox recurrence. </p>
<p>This function has been derived from the netlib Dierckx function fpbspl(). The original fortran coments are:</p>
<pre class="fragment"> Subroutine fpbspl evaluates the (k+1) non-zero b-splines of
 degree k at t(l) &lt;= x &lt; t(l+1) using the stable recurrence
 relation of de Boor and Cox.</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Array of knot positions. </td></tr>
    <tr><td class="paramname">k</td><td>Degree of the B-Spline. </td></tr>
    <tr><td class="paramname">x</td><td>Point at which the spline is to be evaluated. </td></tr>
    <tr><td class="paramname">l</td><td>Knot index st k at t[l] &lt;= x &lt; t[l+1]. </td></tr>
    <tr><td class="paramname">h</td><td>Array with length &gt;= k in which to evaluate the spline. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="group__AlgFit.html#ga0f5ba44db195ed6f2c3d44468bf6235e">AlgBSplineDer()</a>, and <a class="el" href="group__AlgFit.html#ga509bd266ecdf5ca999f8a99d9665a90e">AlgBSplineEval()</a>.</p>

</div>
</div>
<a id="ga39fcbe5976c8836909cee34bba5efea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39fcbe5976c8836909cee34bba5efea3">&#9670;&nbsp;</a></span>AlgBSplineNDFit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AlgType_8h.html#aef11f3ce7e5ac4471a5d3359996838c0">AlgError</a> AlgBSplineNDFit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iopt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ipar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>wrk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwrk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a smooth approximating b-spline in multi-dimensional space. </p>
<dl class="section return"><dt>Returns</dt><dd>Alg error code.</dd></dl>
<p>This function has been derived from the netlib Dierckx function curfit(). The original fortran coments are:</p>
<pre class="fragment"> Given the ordered set of m points x(i) in the idim-dimensional space
 and given also a corresponding set of strictly increasing values u(i)
 and the set of positive numbers w(i),i=1,2,...,m, subroutine parcur
 determines a smooth approximating spline curve s(u), i.e.
     x1 = s1(u)
     x2 = s2(u)       ub &lt;= u &lt;= ue
     .........
     xidim = sidim(u)
 with sj(u),j=1,2,...,idim spline functions of degree k with common
 knots t(j),j=1,2,...,n.
 if ipar=1 the values ub,ue and u(i),i=1,2,...,m must be supplied by
 the user. if ipar=0 these values are chosen automatically by parcur
 as  v(1) = 0
     v(i) = v(i-1) + dist(x(i),x(i-1)) ,i=2,3,...,m
     u(i) = v(i)/v(m) ,i=1,2,...,m
     ub = u(1) = 0, ue = u(m) = 1.
 if iopt=-1 parcur calculates the weighted least-squares spline curve
 according to a given set of knots.
 if iopt&gt;=0 the number of knots of the splines sj(u) and the position
 t(j),j=1,2,...,n is chosen automatically by the routine. the smooth-
 ness of s(u) is then achieved by minimalizing the discontinuity
 jumps of the k-th derivative of s(u) at the knots t(j),j=k+2,k+3,...,
 n-k-1. the amount of smoothness is determined by the condition that
 f(p)=sum((w(i)*dist(x(i),s(u(i))))**2) be &lt;= s, with s a given non-
 negative constant, called the smoothing factor.
 the fit s(u) is given in the b-spline representation and can be
 evaluated by means of subroutine curev.

 calling sequence:
    call parcur(iopt,ipar,idim,m,u,mx,x,w,ub,ue,k,s,nest,n,t,nc,c,
   * fp,wrk,lwrk,iwrk,ier)

 parameters:
  iopt  : integer flag. on entry iopt must specify whether a weighted
          least-squares spline curve (iopt=-1) or a smoothing spline
          curve (iopt=0 or 1) must be determined.if iopt=0 the routine
          will start with an initial set of knots t(i)=ub,t(i+k+1)=ue,
          i=1,2,...,k+1. if iopt=1 the routine will continue with the
          knots found at the last call of the routine.
          attention: a call with iopt=1 must always be immediately
          preceded by another call with iopt=1 or iopt=0.
          unchanged on exit.
  ipar  : integer flag. on entry ipar must specify whether (ipar=1)
          the user will supply the parameter values u(i),ub and ue
          or whether (ipar=0) these values are to be calculated by
          parcur. unchanged on exit.
  idim  : integer. on entry idim must specify the dimension of the
          curve. 0 &lt; idim &lt; 11.
          unchanged on exit.
  m     : integer. on entry m must specify the number of data points.
          m &gt; k. unchanged on exit.
  u     : real array of dimension at least (m). in case ipar=1,before
          entry, u(i) must be set to the i-th value of the parameter
          variable u for i=1,2,...,m. these values must then be
          supplied in strictly ascending order and will be unchanged
          on exit. in case ipar=0, on exit,array u will contain the
          values u(i) as determined by parcur.
  mx    : integer. on entry mx must specify the actual dimension of
          the array x as declared in the calling (sub)program. mx must
          not be too small (see x). unchanged on exit.
  x     : real array of dimension at least idim*m.
          before entry, x(idim*(i-1)+j) must contain the j-th coord-
          inate of the i-th data point for i=1,2,...,m and j=1,2,...,
          idim. unchanged on exit.
  w     : real array of dimension at least (m). before entry, w(i)
          must be set to the i-th value in the set of weights. the
          w(i) must be strictly positive. unchanged on exit.
          see also further comments.
  ub,ue : real values. on entry (in case ipar=1) ub and ue must
          contain the lower and upper bound for the parameter u.
          ub &lt;=u(1), ue&gt;= u(m). if ipar = 0 these values will
          automatically be set to 0 and 1 by parcur.
  k     : integer. on entry k must specify the degree of the splines.
          1&lt;=k&lt;=5. it is recommended to use cubic splines (k=3).
          the user is strongly dissuaded from choosing k even,together
          with a small s-value. unchanged on exit.
  s     : real.on entry (in case iopt&gt;=0) s must specify the smoothing
          factor. s &gt;=0. unchanged on exit.
          for advice on the choice of s see further comments.
  nest  : integer. on entry nest must contain an over-estimate of the
          total number of knots of the splines returned, to indicate
          the storage space available to the routine. nest &gt;=2*k+2.
          in most practical situation nest=m/2 will be sufficient.
          always large enough is nest=m+k+1, the number of knots
          needed for interpolation (s=0). unchanged on exit.
  n     : integer.
          unless ier = 10 (in case iopt &gt;=0), n will contain the
          total number of knots of the smoothing spline curve returned
          if the computation mode iopt=1 is used this value of n
          should be left unchanged between subsequent calls.
          in case iopt=-1, the value of n must be specified on entry.
  t     : real array of dimension at least (nest).
          on succesful exit, this array will contain the knots of the
          spline curve,i.e. the position of the interior knots t(k+2),
          t(k+3),..,t(n-k-1) as well as the position of the additional
          t(1)=t(2)=...=t(k+1)=ub and t(n-k)=...=t(n)=ue needed for
          the b-spline representation.
          if the computation mode iopt=1 is used, the values of t(1),
          t(2),...,t(n) should be left unchanged between subsequent
          calls. if the computation mode iopt=-1 is used, the values
          t(k+2),...,t(n-k-1) must be supplied by the user, before
          entry. see also the restrictions (ier=10).
  nc    : integer. on entry nc must specify the actual dimension of
          the array c as declared in the calling (sub)program. nc
          must not be too small (see c). unchanged on exit.
  c     : real array of dimension at least (nest*idim).
          on succesful exit, this array will contain the coefficients
          in the b-spline representation of the spline curve s(u),i.e.
          the b-spline coefficients of the spline sj(u) will be given
          in c(n*(j-1)+i),i=1,2,...,n-k-1 for j=1,2,...,idim.
  fp    : real. unless ier = 10, fp contains the weighted sum of
          squared residuals of the spline curve returned.
  wrk   : real array of dimension at least m*(k+1)+nest*(6+idim+3*k).
          used as working space. if the computation mode iopt=1 is
          used, the values wrk(1),...,wrk(n) should be left unchanged
          between subsequent calls.
  lwrk  : integer. on entry,lwrk must specify the actual dimension of
          the array wrk as declared in the calling (sub)program. lwrk
          must not be too small (see wrk). unchanged on exit.
  iwrk  : integer array of dimension at least (nest).
          used as working space. if the computation mode iopt=1 is
          used,the values iwrk(1),...,iwrk(n) should be left unchanged
          between subsequent calls.
  ier   : integer. unless the routine detects an error, ier contains a
          non-positive value on exit, i.e.
   ier=0  : normal return. the curve returned has a residual sum of
            squares fp such that abs(fp-s)/s &lt;= tol with tol a relat-
            ive tolerance set to 0.001 by the program.
   ier=-1 : normal return. the curve returned is an interpolating
            spline curve (fp=0).
   ier=-2 : normal return. the curve returned is the weighted least-
            squares polynomial curve of degree k.in this extreme case
            fp gives the upper bound fp0 for the smoothing factor s.
   ier=1  : error. the required storage space exceeds the available
            storage space, as specified by the parameter nest.
            probably causes : nest too small. if nest is already
            large (say nest &gt; m/2), it may also indicate that s is
            too small
            the approximation returned is the least-squares spline
            curve according to the knots t(1),t(2),...,t(n). (n=nest)
            the parameter fp gives the corresponding weighted sum of
            squared residuals (fp&gt;s).
   ier=2  : error. a theoretically impossible result was found during
            the iteration proces for finding a smoothing spline curve
            with fp = s. probably causes : s too small.
            there is an approximation returned but the corresponding
            weighted sum of squared residuals does not satisfy the
            condition abs(fp-s)/s &lt; tol.
   ier=3  : error. the maximal number of iterations maxit (set to 20
            by the program) allowed for finding a smoothing curve
            with fp=s has been reached. probably causes : s too small
            there is an approximation returned but the corresponding
            weighted sum of squared residuals does not satisfy the
            condition abs(fp-s)/s &lt; tol.
   ier=10 : error. on entry, the input data are controlled on validity
            the following restrictions must be satisfied.
            -1&lt;=iopt&lt;=1, 1&lt;=k&lt;=5, m&gt;k, nest&gt;2*k+2, w(i)&gt;0,i=1,2,...,m
            0&lt;=ipar&lt;=1, 0&lt;idim&lt;=10, lwrk&gt;=(k+1)*m+nest*(6+idim+3*k),
            nc&gt;=nest*idim
            if ipar=0: sum j=1,idim (x(idim*i+j)-x(idim*(i-1)+j))**2&gt;0
                       i=1,2,...,m-1.
            if ipar=1: ub&lt;=u(1)&lt;u(2)&lt;...&lt;u(m)&lt;=ue
            if iopt=-1: 2*k+2&lt;=n&lt;=min(nest,m+k+1)
                        ub&lt;t(k+2)&lt;t(k+3)&lt;...&lt;t(n-k-1)&lt;ue
                           (ub=0 and ue=1 in case ipar=0)
                      the schoenberg-whitney conditions, i.e. there
                      must be a subset of data points uu(j) such that
                        t(j) &lt; uu(j) &lt; t(j+k+1), j=1,2,...,n-k-1
            if iopt&gt;=0: s&gt;=0
                        if s=0 : nest &gt;= m+k+1
            if one of these conditions is found to be violated,control
            is immediately repassed to the calling program. in that
            case there is no approximation returned.

 further comments:
  by means of the parameter s, the user can control the tradeoff
  between closeness of fit and smoothness of fit of the approximation.
  if s is too large, the curve will be too smooth and signal will be
  lost ; if s is too small the curve will pick up too much noise. in
  the extreme cases the program will return an interpolating curve if
  s=0 and the least-squares polynomial curve of degree k if s is
  very large. between these extremes, a properly chosen s will result
  in a good compromise between closeness of fit and smoothness of fit.
  to decide whether an approximation, corresponding to a certain s is
  satisfactory the user is highly recommended to inspect the fits
  graphically.
  recommended values for s depend on the weights w(i). if these are
  taken as 1/d(i) with d(i) an estimate of the standard deviation of
  x(i), a good s-value should be found in the range (m-sqrt(2*m),m+
  sqrt(2*m)). if nothing is known about the statistical error in x(i)
  each w(i) can be set equal to one and s determined by trial and
  error, taking account of the comments above. the best is then to
  start with a very large value of s ( to determine the least-squares
  polynomial curve and the upper bound fp0 for s) and then to
  progressively decrease the value of s ( say by a factor 10 in the
  beginning, i.e. s=fp0/10, fp0/100,...and more carefully as the
  approximating curve shows more detail) to obtain closer fits.
  to economize the search for a good s-value the program provides with
  different modes of computation. at the first call of the routine, or
  whenever he wants to restart with the initial set of knots the user
  must set iopt=0.
  if iopt=1 the program will continue with the set of knots found at
  the last call of the routine. this will save a lot of computation
  time if parcur is called repeatedly for different values of s.
  the number of knots of the spline returned and their location will
  depend on the value of s and on the complexity of the shape of the
  curve underlying the data. but, if the computation mode iopt=1 is
  used, the knots returned may also depend on the s-values at previous
  calls (if these were smaller). therefore, if after a number of
  trials with different s-values and iopt=1, the user can finally
  accept a fit as satisfactory, it may be worthwhile for him to call
  parcur once more with the selected value for s but now with iopt=0.
  indeed, parcur may then return an approximation of the same quality
  of fit but with fewer knots and therefore better if data reduction
  is also an important objective for the user.

  the form of the approximating curve can strongly be affected by
  the choice of the parameter values u(i). if there is no physical
  reason for choosing a particular parameter u, often good results
  will be obtained with the choice of parcur (in case ipar=0), i.e.
       v(1)=0, v(i)=v(i-1)+q(i), i=2,...,m, u(i)=v(i)/v(m), i=1,..,m
  where
       q(i)= sqrt(sum j=1,idim (xj(i)-xj(i-1))**2 )
  other possibilities for q(i) are
       q(i)= sum j=1,idim (xj(i)-xj(i-1))**2
       q(i)= sum j=1,idim abs(xj(i)-xj(i-1))
       q(i)= max j=1,idim abs(xj(i)-xj(i-1))
       q(i)= 1

 other subroutines required:
   fpback,fpbspl,fpchec,fppara,fpdisc,fpgivs,fpknot,fprati,fprota

 references:
  dierckx p. : algorithms for smoothing data with periodic and
               parametric splines, computer graphics and image
               processing 20 (1982) 171-184.
  dierckx p. : algorithms for smoothing data with periodic and param-
               etric splines, report tw55, dept. computer science,
               k.u.leuven, 1981.
  dierckx p. : curve and surface fitting with splines, monographs on
               numerical analysis, oxford university press, 1993.

 author:
   p.dierckx
   dept. computer science, k.u. leuven
   celestijnenlaan 200a, b-3001 heverlee, belgium.
   e-mail : Paul.Dierckx@cs.kuleuven.ac.be

 creation date : may 1979
 latest update : march 1987</pre><ul>
<li><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iopt</td><td>Option for how spline is computed. </td></tr>
    <tr><td class="paramname">ipar</td><td>If parameter values u[], ub and ue are supplied the must be 1, else 0. </td></tr>
    <tr><td class="paramname">idim</td><td>Curve dimension (0 &lt; idim &lt; 11). </td></tr>
    <tr><td class="paramname">m</td><td>Number of data points. </td></tr>
    <tr><td class="paramname">u</td><td>Array of parameter variables. </td></tr>
    <tr><td class="paramname">mx</td><td>Dimension of the array x. </td></tr>
    <tr><td class="paramname">x</td><td>Independent data. </td></tr>
    <tr><td class="paramname">w</td><td>Weights for data points. </td></tr>
    <tr><td class="paramname">ub</td><td>Lower bound of parameter values if ipar == 1. </td></tr>
    <tr><td class="paramname">ue</td><td>Upper bound of parameter values if ipar == 1. </td></tr>
    <tr><td class="paramname">k</td><td>Degree of spline. </td></tr>
    <tr><td class="paramname">s</td><td>Smoothing parameter. </td></tr>
    <tr><td class="paramname">nest</td><td>Over estimate of the number of knots to be returned (eg) </td></tr>
    <tr><td class="paramname">n</td><td>Destination pointer for the number of knots returned. </td></tr>
    <tr><td class="paramname">t</td><td>Array for returned computed knots. </td></tr>
    <tr><td class="paramname">nc</td><td><br />
</td></tr>
    <tr><td class="paramname">c</td><td>Array for returned spline coefficients. </td></tr>
    <tr><td class="paramname">fp</td><td>Weighted sum of squared residuals of the spline approximation returned. </td></tr>
    <tr><td class="paramname">wrk</td><td>Workspace with minimum size m * (k + 1) + nest * (idim + 6 + k * 3). </td></tr>
    <tr><td class="paramname">iwrk</td><td>Workspace with minimum size nest * idim. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

<p class="reference">References <a class="el" href="AlgType_8h.html#a13b4d2a4cbe8c92ac2c0b593a23a74a8a5c991c34969bcdd76e5b9433255374a8">ALG_ERR_FUNC</a>, and <a class="el" href="AlgType_8h.html#a13b4d2a4cbe8c92ac2c0b593a23a74a8a8d756ca6d185d2c21c2a479330f1595c">ALG_ERR_NONE</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__WlzFeatures.html#gac59b71124d78214daf269193352b0341">WlzBSplineFromVertices()</a>.</p>

</div>
</div>
<a id="ga900b986ff7f6be5385dd1f5c51abc4f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga900b986ff7f6be5385dd1f5c51abc4f0">&#9670;&nbsp;</a></span>AlgBSplinePerFit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AlgType_8h.html#aef11f3ce7e5ac4471a5d3359996838c0">AlgError</a> AlgBSplinePerFit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iopt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>wrk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwrk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a smooth periodic B-spline approximation through the given data. </p>
<dl class="section return"><dt>Returns</dt><dd>Alg error code.</dd></dl>
<p>This function has been derived from the netlib Dierckx function percur(). The original fortran coments are:</p>
<pre class="fragment">Given the set of data points (x(i),y(i)) and the set of positive 
numbers w(i),i=1,2,...,m-1, subroutine percur determines a smooth 
periodic spline approximation of degree k with period per=x(m)-x(1). 
if iopt=-1 percur calculates the weighted least-squares periodic 
spline according to a given set of knots. 
if iopt&gt;=0 the number of knots of the spline s(x) and the position 
t(j),j=1,2,...,n is chosen automatically by the routine. the smooth- 
ness of s(x) is then achieved by minimalizing the discontinuity 
jumps of the k-th derivative of s(x) at the knots t(j),j=k+2,k+3,..., 
n-k-1. the amount of smoothness is determined by the condition that 
f(p)=sum((w(i)*(y(i)-s(x(i))))**2) be &lt;= s, with s a given non- 
negative constant, called the smoothing factor. 
the fit s(x) is given in the b-spline representation (b-spline coef- 
ficients c(j),j=1,2,...,n-k-1) and can be evaluated by means of 
subroutine splev. 

calling sequence: 
   call percur(iopt,m,x,y,w,k,s,nest,n,t,c,fp,wrk, lwrk,iwrk,ier) 

parameters: 
 iopt  : integer flag. on entry iopt must specify whether a weighted 
         least-squares spline (iopt=-1) or a smoothing spline (iopt= 
         0 or 1) must be determined. if iopt=0 the routine will start 
         with an initial set of knots t(i)=x(1)+(x(m)-x(1))*(i-k-1), 
         i=1,2,...,2*k+2. if iopt=1 the routine will continue with 
         the knots found at the last call of the routine. 
         attention: a call with iopt=1 must always be immediately 
         preceded by another call with iopt=1 or iopt=0. 
         unchanged on exit. 
 m     : integer. on entry m must specify the number of data points. 
         m &gt; 1. unchanged on exit. 
 x     : real array of dimension at least (m). before entry, x(i) 
         must be set to the i-th value of the independent variable x, 
         for i=1,2,...,m. these values must be supplied in strictly 
         ascending order. x(m) only indicates the length of the 
         period of the spline, i.e per=x(m)-x(1). 
         unchanged on exit. 
 y     : real array of dimension at least (m). before entry, y(i) 
         must be set to the i-th value of the dependent variable y, 
         for i=1,2,...,m-1. the element y(m) is not used. 
         unchanged on exit. 
 w     : real array of dimension at least (m). before entry, w(i) 
         must be set to the i-th value in the set of weights. the 
         w(i) must be strictly positive. w(m) is not used. 
         see also further comments. unchanged on exit. 
 k     : integer. on entry k must specify the degree of the spline. 
         1&lt;=k&lt;=5. it is recommended to use cubic splines (k=3). 
         the user is strongly dissuaded from choosing k even,together 
         with a small s-value. unchanged on exit. 
 s     : real.on entry (in case iopt&gt;=0) s must specify the smoothing 
         factor. s &gt;=0. unchanged on exit. 
         for advice on the choice of s see further comments. 
 nest  : integer. on entry nest must contain an over-estimate of the 
         total number of knots of the spline returned, to indicate 
         the storage space available to the routine. nest &gt;=2*k+2. 
         in most practical situation nest=m/2 will be sufficient. 
         always large enough is nest=m+2*k,the number of knots needed 
         for interpolation (s=0). unchanged on exit. 
 n     : integer. 
         unless ier = 10 (in case iopt &gt;=0), n will contain the 
         total number of knots of the spline approximation returned. 
         if the computation mode iopt=1 is used this value of n 
         should be left unchanged between subsequent calls. 
         in case iopt=-1, the value of n must be specified on entry. 
 t     : real array of dimension at least (nest). 
         on succesful exit, this array will contain the knots of the 
         spline,i.e. the position of the interior knots t(k+2),t(k+3) 
         ...,t(n-k-1) as well as the position of the additional knots 
         t(1),t(2),...,t(k+1)=x(1) and t(n-k)=x(m),..,t(n) needed for 
         the b-spline representation. 
         if the computation mode iopt=1 is used, the values of t(1), 
         t(2),...,t(n) should be left unchanged between subsequent 
         calls. if the computation mode iopt=-1 is used, the values 
         t(k+2),...,t(n-k-1) must be supplied by the user, before 
         entry. see also the restrictions (ier=10). 
 c     : real array of dimension at least (nest). 
         on succesful exit, this array will contain the coefficients 
         c(1),c(2),..,c(n-k-1) in the b-spline representation of s(x) 
 fp    : real. unless ier = 10, fp contains the weighted sum of 
         squared residuals of the spline approximation returned. 
 wrk   : real array of dimension at least (m*(k+1)+nest*(8+5*k)). 
         used as working space. if the computation mode iopt=1 is 
         used, the values wrk(1),...,wrk(n) should be left unchanged 
         between subsequent calls. 
 lwrk  : integer. on entry,lwrk must specify the actual dimension of 
         the array wrk as declared in the calling (sub)program. lwrk 
         must not be too small (see wrk). unchanged on exit. 
 iwrk  : integer array of dimension at least (nest). 
         used as working space. if the computation mode iopt=1 is 
         used,the values iwrk(1),...,iwrk(n) should be left unchanged 
         between subsequent calls. 
 ier   : integer. unless the routine detects an error, ier contains a 
         non-positive value on exit, i.e. 
  ier=0  : normal return. the spline returned has a residual sum of 
           squares fp such that abs(fp-s)/s &lt;= tol with tol a relat- 
           ive tolerance set to 0.001 by the program. 
  ier=-1 : normal return. the spline returned is an interpolating 
           periodic spline (fp=0). 
  ier=-2 : normal return. the spline returned is the weighted least- 
           squares constant. in this extreme case fp gives the upper 
           bound fp0 for the smoothing factor s. 
  ier=1  : error. the required storage space exceeds the available 
           storage space, as specified by the parameter nest. 
           probably causes : nest too small. if nest is already 
           large (say nest &gt; m/2), it may also indicate that s is 
           too small 
           the approximation returned is the least-squares periodic 
           spline according to the knots t(1),t(2),...,t(n). (n=nest) 
           the parameter fp gives the corresponding weighted sum of 
           squared residuals (fp&gt;s). 
  ier=2  : error. a theoretically impossible result was found during 
           the iteration proces for finding a smoothing spline with 
           fp = s. probably causes : s too small. 
           there is an approximation returned but the corresponding 
           weighted sum of squared residuals does not satisfy the 
           condition abs(fp-s)/s &lt; tol. 
  ier=3  : error. the maximal number of iterations maxit (set to 20 
           by the program) allowed for finding a smoothing spline 
           with fp=s has been reached. probably causes : s too small 
           there is an approximation returned but the corresponding 
           weighted sum of squared residuals does not satisfy the 
           condition abs(fp-s)/s &lt; tol. 
  ier=10 : error. on entry, the input data are controlled on validity 
           the following restrictions must be satisfied. 
           -1&lt;=iopt&lt;=1, 1&lt;=k&lt;=5, m&gt;1, nest&gt;2*k+2, w(i)&gt;0,i=1,...,m-1 
           x(1)&lt;x(2)&lt;...&lt;x(m), lwrk&gt;=(k+1)*m+nest*(8+5*k) 
           if iopt=-1: 2*k+2&lt;=n&lt;=min(nest,m+2*k) 
                       x(1)&lt;t(k+2)&lt;t(k+3)&lt;...&lt;t(n-k-1)&lt;x(m) 
                     the schoenberg-whitney conditions, i.e. there 
                     must be a subset of data points xx(j) with 
                     xx(j) = x(i) or x(i)+(x(m)-x(1)) such that 
                       t(j) &lt; xx(j) &lt; t(j+k+1), j=k+1,...,n-k-1 
           if iopt&gt;=0: s&gt;=0 
                       if s=0 : nest &gt;= m+2*k 
           if one of these conditions is found to be violated,control 
           is immediately repassed to the calling program. in that 
           case there is no approximation returned. 

further comments: 
 by means of the parameter s, the user can control the tradeoff 
 between closeness of fit and smoothness of fit of the approximation. 
 if s is too large, the spline will be too smooth and signal will be 
 lost ; if s is too small the spline will pick up too much noise. in 
 the extreme cases the program will return an interpolating periodic 
 spline if s=0 and the weighted least-squares constant if s is very 
 large. between these extremes, a properly chosen s will result in 
 a good compromise between closeness of fit and smoothness of fit. 
 to decide whether an approximation, corresponding to a certain s is 
 satisfactory the user is highly recommended to inspect the fits 
 graphically. 
 recommended values for s depend on the weights w(i). if these are 
 taken as 1/d(i) with d(i) an estimate of the standard deviation of 
 y(i), a good s-value should be found in the range (m-sqrt(2*m),m+ 
 sqrt(2*m)). if nothing is known about the statistical error in y(i) 
 each w(i) can be set equal to one and s determined by trial and 
 error, taking account of the comments above. the best is then to 
 start with a very large value of s ( to determine the least-squares 
 constant and the corresponding upper bound fp0 for s) and then to 
 progressively decrease the value of s ( say by a factor 10 in the 
 beginning, i.e. s=fp0/10, fp0/100,...and more carefully as the 
 approximation shows more detail) to obtain closer fits. 
 to economize the search for a good s-value the program provides with 
 different modes of computation. at the first call of the routine, or 
 whenever he wants to restart with the initial set of knots the user 
 must set iopt=0. 
 if iopt=1 the program will continue with the set of knots found at 
 the last call of the routine. this will save a lot of computation 
 time if percur is called repeatedly for different values of s. 
 the number of knots of the spline returned and their location will 
 depend on the value of s and on the complexity of the shape of the 
 function underlying the data. but, if the computation mode iopt=1 
 is used, the knots returned may also depend on the s-values at 
 previous calls (if these were smaller). therefore, if after a number 
 of trials with different s-values and iopt=1, the user can finally 
 accept a fit as satisfactory, it may be worthwhile for him to call 
 percur once more with the selected value for s but now with iopt=0. 
 indeed, percur may then return an approximation of the same quality 
 of fit but with fewer knots and therefore better if data reduction 
 is also an important objective for the user. 

other subroutines required: 
  fpbacp,fpbspl,fpchep,fpperi,fpdisc,fpgivs,fpknot,fprati,fprota 

references: 
 dierckx p. : algorithms for smoothing data with periodic and 
              parametric splines, computer graphics and image 
              processing 20 (1982) 171-184. 
 dierckx p. : algorithms for smoothing data with periodic and param- 
              etric splines, report tw55, dept. computer science, 
              k.u.leuven, 1981. 
 dierckx p. : curve and surface fitting with splines, monographs on 
              numerical analysis, oxford university press, 1993. 

author: 
  p.dierckx 
  dept. computer science, k.u. leuven 
  celestijnenlaan 200a, b-3001 heverlee, belgium. 
  e-mail : Paul.Dierckx@cs.kuleuven.ac.be 

creation date : may 1979 
latest update : march 1987 
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iopt</td><td>Option for how spline is computed. </td></tr>
    <tr><td class="paramname">m</td><td>Number of data points. </td></tr>
    <tr><td class="paramname">x</td><td>Independent data. </td></tr>
    <tr><td class="paramname">y</td><td>Dependent data. </td></tr>
    <tr><td class="paramname">w</td><td>Weights for data points. </td></tr>
    <tr><td class="paramname">k</td><td>Degree of spline. </td></tr>
    <tr><td class="paramname">s</td><td>Smoothing parameter. </td></tr>
    <tr><td class="paramname">nest</td><td>Over estimate of the number of knots to be returned (eg m + 2 * (k + 1)). </td></tr>
    <tr><td class="paramname">n</td><td>Destination pointer for the number of knots returned. </td></tr>
    <tr><td class="paramname">t</td><td>Array for returned computed knots. </td></tr>
    <tr><td class="paramname">c</td><td>Array for returned spline coefficients. </td></tr>
    <tr><td class="paramname">fp</td><td>Weighted sum of squared residuals of the spline approximation returned. </td></tr>
    <tr><td class="paramname">wrk</td><td>Workspace with minimum size (m * (k + 1) + nest * (8 + 5 * k)). </td></tr>
    <tr><td class="paramname">iwrk</td><td>Workspace with minimum size nest. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="AlgType_8h.html#a13b4d2a4cbe8c92ac2c0b593a23a74a8a5c991c34969bcdd76e5b9433255374a8">ALG_ERR_FUNC</a>, and <a class="el" href="AlgType_8h.html#a13b4d2a4cbe8c92ac2c0b593a23a74a8a8d756ca6d185d2c21c2a479330f1595c">ALG_ERR_NONE</a>.</p>

</div>
</div>
<a id="gaad759d14c2f79746e3612145520ec919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad759d14c2f79746e3612145520ec919">&#9670;&nbsp;</a></span>AlgBSplineFit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AlgType_8h.html#aef11f3ce7e5ac4471a5d3359996838c0">AlgError</a> AlgBSplineFit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iopt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>wrk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iwrk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a smooth B-spline approximation through the given data. </p>
<dl class="section return"><dt>Returns</dt><dd>Alg error code.</dd></dl>
<p>This function has been derived from the netlib Dierckx function curfit(). The original fortran coments are:</p>
<pre class="fragment"> given the set of data points (x(i),y(i)) and the set of positive
 numbers w(i),i=1,2,...,m,subroutine curfit determines a smooth spline
 approximation of degree k on the interval xb &lt;= x &lt;= xe.
 if iopt=-1 curfit calculates the weighted least-squares spline
 according to a given set of knots.
 if iopt&gt;=0 the number of knots of the spline s(x) and the position
 t(j),j=1,2,...,n is chosen automatically by the routine. the smooth-
 ness of s(x) is then achieved by minimalizing the discontinuity
 jumps of the k-th derivative of s(x) at the knots t(j),j=k+2,k+3,...,
 n-k-1. the amount of smoothness is determined by the condition that
 f(p)=sum((w(i)*(y(i)-s(x(i))))**2) be &lt;= s, with s a given non-
 negative constant, called the smoothing factor.
 the fit s(x) is given in the b-spline representation (b-spline coef-
 ficients c(j),j=1,2,...,n-k-1) and can be evaluated by means of
 subroutine splev.

 calling sequence:
    call curfit(iopt,m,x,y,w,xb,xe,k,s,nest,n,t,c,fp,wrk,
   * lwrk,iwrk,ier)

 parameters:
  iopt  : integer flag. on entry iopt must specify whether a weighted
          least-squares spline (iopt=-1) or a smoothing spline (iopt=
          0 or 1) must be determined. if iopt=0 the routine will start
          with an initial set of knots t(i)=xb, t(i+k+1)=xe, i=1,2,...
          k+1. if iopt=1 the routine will continue with the knots
          found at the last call of the routine.
          attention: a call with iopt=1 must always be immediately
          preceded by another call with iopt=1 or iopt=0.
          unchanged on exit.
  m     : integer. on entry m must specify the number of data points.
          m &gt; k. unchanged on exit.
  x     : real array of dimension at least (m). before entry, x(i)
          must be set to the i-th value of the independent variable x,
          for i=1,2,...,m. these values must be supplied in strictly
          ascending order. unchanged on exit.
  y     : real array of dimension at least (m). before entry, y(i)
          must be set to the i-th value of the dependent variable y,
          for i=1,2,...,m. unchanged on exit.
  w     : real array of dimension at least (m). before entry, w(i)
          must be set to the i-th value in the set of weights. the
          w(i) must be strictly positive. unchanged on exit.
          see also further comments.
  xb,xe : real values. on entry xb and xe must specify the boundaries
          of the approximation interval. xb&lt;=x(1), xe&gt;=x(m).
          unchanged on exit.
  k     : integer. on entry k must specify the degree of the spline.
          1&lt;=k&lt;=5. it is recommended to use cubic splines (k=3).
          the user is strongly dissuaded from choosing k even,together
          with a small s-value. unchanged on exit.
  s     : real.on entry (in case iopt&gt;=0) s must specify the smoothing
          factor. s &gt;=0. unchanged on exit.
          for advice on the choice of s see further comments.
  nest  : integer. on entry nest must contain an over-estimate of the
          total number of knots of the spline returned, to indicate
          the storage space available to the routine. nest &gt;=2*k+2.
          in most practical situation nest=m/2 will be sufficient.
          always large enough is  nest=m+k+1, the number of knots
          needed for interpolation (s=0). unchanged on exit.
  n     : integer.
          unless ier =10 (in case iopt &gt;=0), n will contain the
          total number of knots of the spline approximation returned.
          if the computation mode iopt=1 is used this value of n
          should be left unchanged between subsequent calls.
          in case iopt=-1, the value of n must be specified on entry.
  t     : real array of dimension at least (nest).
          on succesful exit, this array will contain the knots of the
          spline,i.e. the position of the interior knots t(k+2),t(k+3)
          ...,t(n-k-1) as well as the position of the additional knots
          t(1)=t(2)=...=t(k+1)=xb and t(n-k)=...=t(n)=xe needed for
          the b-spline representation.
          if the computation mode iopt=1 is used, the values of t(1),
          t(2),...,t(n) should be left unchanged between subsequent
          calls. if the computation mode iopt=-1 is used, the values
          t(k+2),...,t(n-k-1) must be supplied by the user, before
          entry. see also the restrictions (ier=10).
  c     : real array of dimension at least (nest).
          on succesful exit, this array will contain the coefficients
          c(1),c(2),..,c(n-k-1) in the b-spline representation of s(x)
  fp    : real. unless ier=10, fp contains the weighted sum of
          squared residuals of the spline approximation returned.
  wrk   : real array of dimension at least (m*(k+1)+nest*(7+3*k)).
          used as working space. if the computation mode iopt=1 is
          used, the values wrk(1),...,wrk(n) should be left unchanged
          between subsequent calls.
  lwrk  : integer. on entry,lwrk must specify the actual dimension of
          the array wrk as declared in the calling (sub)program.lwrk
          must not be too small (see wrk). unchanged on exit.
  iwrk  : integer array of dimension at least (nest).
          used as working space. if the computation mode iopt=1 is
          used,the values iwrk(1),...,iwrk(n) should be left unchanged
          between subsequent calls.
  ier   : integer. unless the routine detects an error, ier contains a
          non-positive value on exit, i.e.
   ier=0  : normal return. the spline returned has a residual sum of
            squares fp such that abs(fp-s)/s &lt;= tol with tol a relat-
            ive tolerance set to 0.001 by the program.
   ier=-1 : normal return. the spline returned is an interpolating
            spline (fp=0).
   ier=-2 : normal return. the spline returned is the weighted least-
            squares polynomial of degree k. in this extreme case fp
            gives the upper bound fp0 for the smoothing factor s.
   ier=1  : error. the required storage space exceeds the available
            storage space, as specified by the parameter nest.
            probably causes : nest too small. if nest is already
            large (say nest &gt; m/2), it may also indicate that s is
            too small
            the approximation returned is the weighted least-squares
            spline according to the knots t(1),t(2),...,t(n). (n=nest)
            the parameter fp gives the corresponding weighted sum of
            squared residuals (fp&gt;s).
   ier=2  : error. a theoretically impossible result was found during
            the iteration proces for finding a smoothing spline with
            fp = s. probably causes : s too small.
            there is an approximation returned but the corresponding
            weighted sum of squared residuals does not satisfy the
            condition abs(fp-s)/s &lt; tol.
   ier=3  : error. the maximal number of iterations maxit (set to 20
            by the program) allowed for finding a smoothing spline
            with fp=s has been reached. probably causes : s too small
            there is an approximation returned but the corresponding
            weighted sum of squared residuals does not satisfy the
            condition abs(fp-s)/s &lt; tol.
   ier=10 : error. on entry, the input data are controlled on validity
            the following restrictions must be satisfied.
            -1&lt;=iopt&lt;=1, 1&lt;=k&lt;=5, m&gt;k, nest&gt;2*k+2, w(i)&gt;0,i=1,2,...,m
            xb&lt;=x(1)&lt;x(2)&lt;...&lt;x(m)&lt;=xe, lwrk&gt;=(k+1)*m+nest*(7+3*k)
            if iopt=-1: 2*k+2&lt;=n&lt;=min(nest,m+k+1)
                        xb&lt;t(k+2)&lt;t(k+3)&lt;...&lt;t(n-k-1)&lt;xe
                      the schoenberg-whitney conditions, i.e. there
                      must be a subset of data points xx(j) such that
                        t(j) &lt; xx(j) &lt; t(j+k+1), j=1,2,...,n-k-1
            if iopt&gt;=0: s&gt;=0
                        if s=0 : nest &gt;= m+k+1
            if one of these conditions is found to be violated,control
            is immediately repassed to the calling program. in that
            case there is no approximation returned.

 further comments:
  by means of the parameter s, the user can control the tradeoff
  between closeness of fit and smoothness of fit of the approximation.
  if s is too large, the spline will be too smooth and signal will be
  lost ; if s is too small the spline will pick up too much noise. in
  the extreme cases the program will return an interpolating spline if
  s=0 and the weighted least-squares polynomial of degree k if s is
  very large. between these extremes, a properly chosen s will result
  in a good compromise between closeness of fit and smoothness of fit.
  to decide whether an approximation, corresponding to a certain s is
  satisfactory the user is highly recommended to inspect the fits
  graphically.
  recommended values for s depend on the weights w(i). if these are
  taken as 1/d(i) with d(i) an estimate of the standard deviation of
  y(i), a good s-value should be found in the range (m-sqrt(2*m),m+
  sqrt(2*m)). if nothing is known about the statistical error in y(i)
  each w(i) can be set equal to one and s determined by trial and
  error, taking account of the comments above. the best is then to
  start with a very large value of s ( to determine the least-squares
  polynomial and the corresponding upper bound fp0 for s) and then to
  progressively decrease the value of s ( say by a factor 10 in the
  beginning, i.e. s=fp0/10, fp0/100,...and more carefully as the
  approximation shows more detail) to obtain closer fits.
  to economize the search for a good s-value the program provides with
  different modes of computation. at the first call of the routine, or
  whenever he wants to restart with the initial set of knots the user
  must set iopt=0.
  if iopt=1 the program will continue with the set of knots found at
  the last call of the routine. this will save a lot of computation
  time if curfit is called repeatedly for different values of s.
  the number of knots of the spline returned and their location will
  depend on the value of s and on the complexity of the shape of the
  function underlying the data. but, if the computation mode iopt=1
  is used, the knots returned may also depend on the s-values at
  previous calls (if these were smaller). therefore, if after a number
  of trials with different s-values and iopt=1, the user can finally
  accept a fit as satisfactory, it may be worthwhile for him to call
  curfit once more with the selected value for s but now with iopt=0.
  indeed, curfit may then return an approximation of the same quality
  of fit but with fewer knots and therefore better if data reduction
  is also an important objective for the user.

 other subroutines required:
   fpback,fpbspl,fpchec,fpcurf,fpdisc,fpgivs,fpknot,fprati,fprota

 references:
  dierckx p. : an algorithm for smoothing, differentiation and integ-
               ration of experimental data using spline functions,
               j.comp.appl.maths 1 (1975) 165-184.
  dierckx p. : a fast algorithm for smoothing data on a rectangular
               grid while using spline functions, siam j.numer.anal.
               19 (1982) 1286-1304.
  dierckx p. : an improved algorithm for curve fitting with spline
               functions, report tw54, dept. computer science,k.u.
               leuven, 1981.
  dierckx p. : curve and surface fitting with splines, monographs on
               numerical analysis, oxford university press, 1993.

 author:
   p.dierckx
   dept. computer science, k.u. leuven
   celestijnenlaan 200a, b-3001 heverlee, belgium.
   e-mail : Paul.Dierckx@cs.kuleuven.ac.be

 creation date : may 1979
 latest update : march 1987</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iopt</td><td>Option for how spline is computed. </td></tr>
    <tr><td class="paramname">m</td><td>Number of data points. </td></tr>
    <tr><td class="paramname">x</td><td>Independent data. </td></tr>
    <tr><td class="paramname">y</td><td>Dependent data. </td></tr>
    <tr><td class="paramname">w</td><td>Weights for data points. </td></tr>
    <tr><td class="paramname">xb</td><td></td></tr>
    <tr><td class="paramname">xe</td><td></td></tr>
    <tr><td class="paramname">k</td><td>Degree of spline. </td></tr>
    <tr><td class="paramname">s</td><td>Smoothing parameter. </td></tr>
    <tr><td class="paramname">nest</td><td>Over estimate of the number of knots to be returned (eg m + k + 1). </td></tr>
    <tr><td class="paramname">n</td><td>Destination pointer for the number of knots returned. </td></tr>
    <tr><td class="paramname">t</td><td>Array for returned computed knots. </td></tr>
    <tr><td class="paramname">c</td><td>Array for returned spline coefficients. </td></tr>
    <tr><td class="paramname">fp</td><td>Weighted sum of squared residuals of the spline approximation returned. </td></tr>
    <tr><td class="paramname">wrk</td><td>Workspace with minimum size m * k1 + nest * (k * 3 + 7) </td></tr>
    <tr><td class="paramname">iwrk</td><td>Workspace with minimum size nest. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="AlgType_8h.html#a13b4d2a4cbe8c92ac2c0b593a23a74a8a5c991c34969bcdd76e5b9433255374a8">ALG_ERR_FUNC</a>, and <a class="el" href="AlgType_8h.html#a13b4d2a4cbe8c92ac2c0b593a23a74a8a8d756ca6d185d2c21c2a479330f1595c">ALG_ERR_NONE</a>.</p>

</div>
</div>
<a id="ga509bd266ecdf5ca999f8a99d9665a90e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga509bd266ecdf5ca999f8a99d9665a90e">&#9670;&nbsp;</a></span>AlgBSplineEval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AlgType_8h.html#aef11f3ce7e5ac4471a5d3359996838c0">AlgError</a> AlgBSplineEval </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates a b-spline at a number of points. </p>
<dl class="section return"><dt>Returns</dt><dd>Alg error code.</dd></dl>
<p>This function has been derived from the netlib Dierckx function splev(). The original fortran coments are:</p>
<pre class="fragment"> Subroutine splev evaluates in a number of points x(i),i=1,2,...,m
 a spline s(x) of degree k, given in its b-spline representation.

 calling sequence:
    call splev(t,n,c,k,x,y,m,ier)

 input parameters:
   t    : array,length n, which contains the position of the knots.
   n    : integer, giving the total number of knots of s(x).
   c    : array,length n, which contains the b-spline coefficients.
   k    : integer, giving the degree of s(x).
   x    : array,length m, which contains the points where s(x) must
          be evaluated.
   m    : integer, giving the number of points where s(x) must be
          evaluated.

 output parameter:
   y    : array,length m, giving the value of s(x) at the different
          points.
   ier  : error flag
     ier = 0 : normal return
     ier =10 : invalid input data (see restrictions)

 restrictions:
   m &gt;= 1
   t(k+1) &lt;= x(i) &lt;= x(i+1) &lt;= t(n-k) , i=1,2,...,m-1.

 other subroutines required: fpbspl.

 references :
   de boor c  : on calculating with b-splines, j. approximation theory
                6 (1972) 50-62.
   cox m.g.   : the numerical evaluation of b-splines, j. inst. maths
                applics 10 (1972) 134-149.
   dierckx p. : curve and surface fitting with splines, monographs on
                numerical analysis, oxford university press, 1993.

 author :
   p.dierckx
   dept. computer science, k.u.leuven
   celestijnenlaan 200a, b-3001 heverlee, belgium.
   e-mail : Paul.Dierckx@cs.kuleuven.ac.be

 latest update : march 1987</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Knot positions. </td></tr>
    <tr><td class="paramname">n</td><td>Number of knots. </td></tr>
    <tr><td class="paramname">c</td><td>B-spline coefficients. </td></tr>
    <tr><td class="paramname">k</td><td>Degree of the B-spline. </td></tr>
    <tr><td class="paramname">x</td><td>Points at which the B-spline must be evaluated. </td></tr>
    <tr><td class="paramname">y</td><td>Array for evaluated B-spline at given points. </td></tr>
    <tr><td class="paramname">m</td><td>Number of points at which B-spline is to be evaluated. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="AlgType_8h.html#a1c9bd9b5c93b9202a23113c826ce762a">ALG_CLAMP</a>, <a class="el" href="AlgType_8h.html#a13b4d2a4cbe8c92ac2c0b593a23a74a8a5c991c34969bcdd76e5b9433255374a8">ALG_ERR_FUNC</a>, <a class="el" href="AlgType_8h.html#a13b4d2a4cbe8c92ac2c0b593a23a74a8a8d756ca6d185d2c21c2a479330f1595c">ALG_ERR_NONE</a>, and <a class="el" href="group__AlgFit.html#ga6e92d82a9e57b56a1f9e4e830953d762">AlgBSplineBspl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__WlzFeatures.html#ga0ab10c9ae18cd890295ca9a5f2237092">WlzBSplineEval()</a>.</p>

</div>
</div>
<a id="ga0f5ba44db195ed6f2c3d44468bf6235e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f5ba44db195ed6f2c3d44468bf6235e">&#9670;&nbsp;</a></span>AlgBSplineDer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AlgType_8h.html#aef11f3ce7e5ac4471a5d3359996838c0">AlgError</a> AlgBSplineDer </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>wrk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the derivatives of order nu of the B-spline of degree k. </p>
<dl class="section return"><dt>Returns</dt><dd>Alg error code.</dd></dl>
<p>This function has been derived from the netlib Dierckx function splder(). The original fortran coments are:</p>
<pre class="fragment"> Subroutine splder evaluates in a number of points x(i),i=1,2,...,m
 the derivative of order nu of a spline s(x) of degree k,given in
 its b-spline representation.

 calling sequence:
    call splder(t,n,c,k,nu,x,y,m,wrk,ier)

 input parameters:
   t    : array,length n, which contains the position of the knots.
   n    : integer, giving the total number of knots of s(x).
   c    : array,length n, which contains the b-spline coefficients.
   k    : integer, giving the degree of s(x).
   nu   : integer, specifying the order of the derivative. 0&lt;=nu&lt;=k
   x    : array,length m, which contains the points where the deriv-
          ative of s(x) must be evaluated.
   m    : integer, giving the number of points where the derivative
          of s(x) must be evaluated
   wrk  : real array of dimension n. used as working space.

 output parameters:
   y    : array,length m, giving the value of the derivative of s(x)
          at the different points.
   ier  : error flag
     ier = 0 : normal return
     ier =10 : invalid input data (see restrictions)

 restrictions:
   0 &lt;= nu &lt;= k
   m &gt;= 1
   t(k+1) &lt;= x(i) &lt;= x(i+1) &lt;= t(n-k) , i=1,2,...,m-1.

 other subroutines required: fpbspl

 references :
   de boor c : on calculating with b-splines, j. approximation theory
               6 (1972) 50-62.
   cox m.g.  : the numerical evaluation of b-splines, j. inst. maths
               applics 10 (1972) 134-149.
  dierckx p. : curve and surface fitting with splines, monographs on
               numerical analysis, oxford university press, 1993.

 author :
   p.dierckx
   dept. computer science, k.u.leuven
   celestijnenlaan 200a, b-3001 heverlee, belgium.
   e-mail : Paul.Dierckx@cs.kuleuven.ac.be

 latest update : march 1987</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Array of knot positions. </td></tr>
    <tr><td class="paramname">n</td><td>Number of knots. </td></tr>
    <tr><td class="paramname">c</td><td>B-spline coefficients. </td></tr>
    <tr><td class="paramname">k</td><td>Degree of the B-Spline. </td></tr>
    <tr><td class="paramname">nu</td><td>Order of the derivative [0-k]. </td></tr>
    <tr><td class="paramname">x</td><td>Positions at which the derivative of the spline is to be evaluated. </td></tr>
    <tr><td class="paramname">y</td><td>Destination for the evaluated derivatives. </td></tr>
    <tr><td class="paramname">m</td><td>Number of data points. </td></tr>
    <tr><td class="paramname">wrk</td><td>Workspace with minimum size n. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="AlgType_8h.html#a1c9bd9b5c93b9202a23113c826ce762a">ALG_CLAMP</a>, <a class="el" href="AlgType_8h.html#a13b4d2a4cbe8c92ac2c0b593a23a74a8a5c991c34969bcdd76e5b9433255374a8">ALG_ERR_FUNC</a>, <a class="el" href="AlgType_8h.html#a13b4d2a4cbe8c92ac2c0b593a23a74a8a8d756ca6d185d2c21c2a479330f1595c">ALG_ERR_NONE</a>, and <a class="el" href="group__AlgFit.html#ga6e92d82a9e57b56a1f9e4e830953d762">AlgBSplineBspl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__WlzFeatures.html#ga0ab10c9ae18cd890295ca9a5f2237092">WlzBSplineEval()</a>.</p>

</div>
</div>
<a id="ga25da23481eb7b8d9c18b8c037b6fbd2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25da23481eb7b8d9c18b8c037b6fbd2e">&#9670;&nbsp;</a></span>AlgLinearFit1D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AlgType_8h.html#aef11f3ce7e5ac4471a5d3359996838c0">AlgError</a> AlgLinearFit1D </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>datSz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>datXA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>datYA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dstA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dstB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dstSigA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dstSigB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dstQ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the least squares best fit straight line (y = a + bx) through the given data, ie linear regression. This function is based on the function fit(): Press W. H., Teukolsky S. A., Vetterling W. T. and Flannery B. P, Numerical Recipies in C, 1992, CUP. </p>
<dl class="section return"><dt>Returns</dt><dd>Error code.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">datSz</td><td>Number of elements in given data arrays array. </td></tr>
    <tr><td class="paramname">datXA</td><td>Data array with 'x' values. </td></tr>
    <tr><td class="paramname">datYA</td><td>Data array with 'y' values. </td></tr>
    <tr><td class="paramname">dstA</td><td>Destination ptr for intercept 'a', may be NULL. </td></tr>
    <tr><td class="paramname">dstB</td><td>Destination ptr for gradient 'b', may be NULL. </td></tr>
    <tr><td class="paramname">dstSigA</td><td>Destination ptr for std dev of 'a', may be NULL. </td></tr>
    <tr><td class="paramname">dstSigB</td><td>Destination ptr for std dev of 'b', may be NULL. </td></tr>
    <tr><td class="paramname">dstQ</td><td>Destination ptr for goodness of fit, may be NULL. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="AlgType_8h.html#a13b4d2a4cbe8c92ac2c0b593a23a74a8a5c991c34969bcdd76e5b9433255374a8">ALG_ERR_FUNC</a>, <a class="el" href="AlgType_8h.html#a13b4d2a4cbe8c92ac2c0b593a23a74a8a8d756ca6d185d2c21c2a479330f1595c">ALG_ERR_NONE</a>, and <a class="el" href="group__AlgGamma.html#gabcb57e68ea7517ebe6a96331d6bc0762">AlgGammaP()</a>.</p>

</div>
</div>
<a id="gaf6b612137729b7de26175d64530b3dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6b612137729b7de26175d64530b3dbe">&#9670;&nbsp;</a></span>AlgLinearFitIdx1D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AlgType_8h.html#aef11f3ce7e5ac4471a5d3359996838c0">AlgError</a> AlgLinearFitIdx1D </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>datXA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>datYA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>idxXA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>idxYA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idxASz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dstA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dstB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dstSigA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dstSigB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dstQ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the least squares best fit straight line (y = a + bx) through the given data, ie linear regression. </p>
<dl class="section return"><dt>Returns</dt><dd>Error code.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">datXA</td><td>Data array with 'x' values. </td></tr>
    <tr><td class="paramname">datYA</td><td>Data array with 'y' values. </td></tr>
    <tr><td class="paramname">idxXA</td><td>Index array with indicies into the 'x' data buffer. for the values use examine. </td></tr>
    <tr><td class="paramname">idxYA</td><td>Index array with indicies into the 'y' data buffer. for the values use examine. </td></tr>
    <tr><td class="paramname">idxASz</td><td>Number of elements in each of the given index arrays. </td></tr>
    <tr><td class="paramname">dstA</td><td>Destination ptr for intercept 'a', may be NULL. </td></tr>
    <tr><td class="paramname">dstB</td><td>Destination ptr for gradient 'b', may be NULL. </td></tr>
    <tr><td class="paramname">dstSigA</td><td>Destination ptr for std dev of 'a', may be NULL. </td></tr>
    <tr><td class="paramname">dstSigB</td><td>Destination ptr for std dev of 'b', may be NULL. </td></tr>
    <tr><td class="paramname">dstQ</td><td>Destination ptr for goodness of fit, may be NULL. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="AlgType_8h.html#a13b4d2a4cbe8c92ac2c0b593a23a74a8a5c991c34969bcdd76e5b9433255374a8">ALG_ERR_FUNC</a>, <a class="el" href="AlgType_8h.html#a13b4d2a4cbe8c92ac2c0b593a23a74a8a8d756ca6d185d2c21c2a479330f1595c">ALG_ERR_NONE</a>, and <a class="el" href="group__AlgGamma.html#gabcb57e68ea7517ebe6a96331d6bc0762">AlgGammaP()</a>.</p>

</div>
</div>
<a id="gaa0621eeda942143f5e7bbec25f63fd38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0621eeda942143f5e7bbec25f63fd38">&#9670;&nbsp;</a></span>AlgPolynomialLSq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AlgType_8h.html#aef11f3ce7e5ac4471a5d3359996838c0">AlgError</a> AlgPolynomialLSq </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>xVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>yVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vecSz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>polyDeg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>cVec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to fit a polynomial to the given data using a least squares approach. </p>
<dl class="section return"><dt>Returns</dt><dd>Error code.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xVec</td><td>Data vector x of size vecSz. </td></tr>
    <tr><td class="paramname">yVec</td><td>Data vector y of size vecSz. </td></tr>
    <tr><td class="paramname">vecSz</td><td>Size of data vectors. </td></tr>
    <tr><td class="paramname">polyDeg</td><td>Degree of ploynomial. </td></tr>
    <tr><td class="paramname">cVec</td><td>Destination vector for the polynomial coefficients, which must have at least polyDeg + 1 elements. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="group__AlcAlloc.html#gad77b9005f66254c5b7ba9a8d25812402">AlcFree()</a>, <a class="el" href="group__AlcAlloc.html#ga588bedeb521cd8de95c6e0a65aa5c339">AlcMalloc()</a>, <a class="el" href="AlgType_8h.html#a5663b98653ea10bca37dc3c1523e3742">ALG_DBG</a>, <a class="el" href="AlgType_8h.html#ae92b20ed51bc5ec56d1950a018076d1dacbd453c1d1505847522b90678459134e">ALG_DBG_LVL_1</a>, <a class="el" href="AlgType_8h.html#ae92b20ed51bc5ec56d1950a018076d1daa223c950e2e83cee5c7a6efc2059a7ef">ALG_DBG_LVL_FN</a>, <a class="el" href="AlgType_8h.html#a13b4d2a4cbe8c92ac2c0b593a23a74a8a5c991c34969bcdd76e5b9433255374a8">ALG_ERR_FUNC</a>, <a class="el" href="AlgType_8h.html#a13b4d2a4cbe8c92ac2c0b593a23a74a8ae6202a8565908dfd796531a772b58c4e">ALG_ERR_MALLOC</a>, <a class="el" href="group__AlgMatrix.html#ga63a83de196074f1938ec2bebfad40bdf">AlgMatrixGaussSolve()</a>, <a class="el" href="AlgMatrix_8c.html#a750be1659dbe948ca8477847c2edece0">AlgMatrixRectFree()</a>, <a class="el" href="group__AlgMatrix.html#gaf08516e91107329a35f87452c156a83f">AlgMatrixRectNew()</a>, <a class="el" href="struct__AlgMatrixRect.html#a3265a43b6dc40317e1e5ca15d4323992">_AlgMatrixRect::array</a>, <a class="el" href="union__AlgMatrix.html#a067d9116df56393a6194b56d27bac522">_AlgMatrix::core</a>, and <a class="el" href="union__AlgMatrix.html#a1564b40a87feedf1bc6629aa2b306630">_AlgMatrix::rect</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
