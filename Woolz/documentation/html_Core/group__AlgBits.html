<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Woolz Image Processing: AlgBits</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Woolz Image Processing
   &#160;<span id="projectnumber">Version 1.7.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__AlgBits.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">AlgBits</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:AlgBits_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AlgBits_8c.html">AlgBits.c</a></td></tr>
<tr class="memdesc:AlgBits_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides bit fiddling functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:AlgGrayCode_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AlgGrayCode_8c.html">AlgGrayCode.c</a></td></tr>
<tr class="memdesc:AlgGrayCode_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides functions for computing Gray codes and their inverse. See Christopher H. Hamilton. "Range Searching Data Structures with Cache Locality" PhD Thesis, Dalhousie University, March 20011. The code within this file is derived from this thesis and the software it refers to. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:AlgHilbertIndex_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AlgHilbertIndex_8c.html">AlgHilbertIndex.c</a></td></tr>
<tr class="memdesc:AlgHilbertIndex_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides functions for Hilbert indices and their inverse. See J. K. Lawder "Calculation of Mappings Between One an n-dimensional Values Using the Hilbert Space-filling Curve", Birkbeck, University of London Research Report BBKCS-00-01, 2000. The code in this technical report has been modifiied to support n-dimensions and variable bit orders without recompilation. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac6ac7fe061b0232991f6e80feee60770"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AlgBits.html#gac6ac7fe061b0232991f6e80feee60770">AlgBitSetCount</a> (unsigned long gMsk)</td></tr>
<tr class="memdesc:gac6ac7fe061b0232991f6e80feee60770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of bits set in the given mask.  <a href="#gac6ac7fe061b0232991f6e80feee60770">More...</a><br /></td></tr>
<tr class="separator:gac6ac7fe061b0232991f6e80feee60770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc49de29ecfaf88c38d8ac38685f3489"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AlgBits.html#gacc49de29ecfaf88c38d8ac38685f3489">AlgBitMostSigSet</a> (unsigned long gMsk)</td></tr>
<tr class="memdesc:gacc49de29ecfaf88c38d8ac38685f3489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the most significant bit set in the given mask. The value returned will be zero if the mask was zero one if the mask had the value 1 or higher integer if the most significant bit set in the mask is greater.  <a href="#gacc49de29ecfaf88c38d8ac38685f3489">More...</a><br /></td></tr>
<tr class="separator:gacc49de29ecfaf88c38d8ac38685f3489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fc0dc354e1452c16f585f885ec1fbab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AlgBits.html#ga3fc0dc354e1452c16f585f885ec1fbab">AlgBitMostSigSetLL</a> (unsigned long long gMsk)</td></tr>
<tr class="memdesc:ga3fc0dc354e1452c16f585f885ec1fbab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the most significant bit set in the given mask. The value returned will be zero if the mask was zero one if the mask had the value 1 or higher integer if the most significant bit set in the mask is greater.  <a href="#ga3fc0dc354e1452c16f585f885ec1fbab">More...</a><br /></td></tr>
<tr class="separator:ga3fc0dc354e1452c16f585f885ec1fbab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6df7e43c1b23100ae4bac7baee7b144f"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AlgBits.html#ga6df7e43c1b23100ae4bac7baee7b144f">AlgBitSetPositions</a> (unsigned int *posA, unsigned long gMsk)</td></tr>
<tr class="memdesc:ga6df7e43c1b23100ae4bac7baee7b144f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of bits set in the given mask and sets the first elements of the given bit position array.  <a href="#ga6df7e43c1b23100ae4bac7baee7b144f">More...</a><br /></td></tr>
<tr class="separator:ga6df7e43c1b23100ae4bac7baee7b144f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5b53afbdd516aefb22579add3a3229b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AlgBits.html#gae5b53afbdd516aefb22579add3a3229b">AlgBitRotateRight</a> (unsigned int g, unsigned int n, unsigned int d)</td></tr>
<tr class="memdesc:gae5b53afbdd516aefb22579add3a3229b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates the given bit mask d places to the right (towards less significant bits) where there are n valid bits in the given bit mask.  <a href="#gae5b53afbdd516aefb22579add3a3229b">More...</a><br /></td></tr>
<tr class="separator:gae5b53afbdd516aefb22579add3a3229b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c6b306cc72a79139f38f2067c5893cb"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AlgBits.html#ga8c6b306cc72a79139f38f2067c5893cb">AlgBitNextNOfM</a> (unsigned long curMsk, int n, int m)</td></tr>
<tr class="memdesc:ga8c6b306cc72a79139f38f2067c5893cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a bit mask which has n bits set and is &lt;= maxMsk, the new bit mask is the next after the given current mask. The maximum number of bits that can be stored in an unsigned long is assumed to be 32. If the actual number is less than this then this code won't work, if it's higher everything should be fine. This function can be used together with <a class="el" href="group__AlgBits.html#ga6df7e43c1b23100ae4bac7baee7b144f" title="Counts the number of bits set in the given mask and sets the first elements of the given bit position...">AlgBitSetPositions()</a> to select all ordered combinations of N of M. Eg to select all ordered combinations of 3 out of 5 this function would return 00111, 01011, 01101, 01110, 10110, 11010, 11100.  <a href="#ga8c6b306cc72a79139f38f2067c5893cb">More...</a><br /></td></tr>
<tr class="separator:ga8c6b306cc72a79139f38f2067c5893cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77608b0ea78e2f78d4378f8dbb11612f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AlgBits.html#ga77608b0ea78e2f78d4378f8dbb11612f">AlgBitNextSet</a> (unsigned long msk, int idC)</td></tr>
<tr class="memdesc:ga77608b0ea78e2f78d4378f8dbb11612f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the index of the next bit set in the given mask using the index to the current bit as the start index. maxMsk, the new bit mask is the next after the given current mask.  <a href="#ga77608b0ea78e2f78d4378f8dbb11612f">More...</a><br /></td></tr>
<tr class="separator:ga77608b0ea78e2f78d4378f8dbb11612f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf791bb557123dbe4daaf3d78a3518103"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AlgBits.html#gaf791bb557123dbe4daaf3d78a3518103">AlgBitNextPowerOfTwo</a> (unsigned int *dstP2I, unsigned int gI)</td></tr>
<tr class="memdesc:gaf791bb557123dbe4daaf3d78a3518103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the next integer that is &gt;= the given integer and has only a single bit set.  <a href="#gaf791bb557123dbe4daaf3d78a3518103">More...</a><br /></td></tr>
<tr class="separator:gaf791bb557123dbe4daaf3d78a3518103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd033ba78f6e9f06b0d2e83078918e1e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AlgBits.html#gabd033ba78f6e9f06b0d2e83078918e1e">AlgBitIsPowerOfTwo</a> (unsigned int gI)</td></tr>
<tr class="memdesc:gabd033ba78f6e9f06b0d2e83078918e1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that the given integer is an integral power of two.  <a href="#gabd033ba78f6e9f06b0d2e83078918e1e">More...</a><br /></td></tr>
<tr class="separator:gabd033ba78f6e9f06b0d2e83078918e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e0a13d3f7f814c1a81022676e4cca50"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AlgBits.html#ga7e0a13d3f7f814c1a81022676e4cca50">AlgGrayCode</a> (unsigned int g)</td></tr>
<tr class="memdesc:ga7e0a13d3f7f814c1a81022676e4cca50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Gray code of the given value.  <a href="#ga7e0a13d3f7f814c1a81022676e4cca50">More...</a><br /></td></tr>
<tr class="separator:ga7e0a13d3f7f814c1a81022676e4cca50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd64d9debbad763a7d5eec21757c53a6"><td class="memItemLeft" align="right" valign="top">unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AlgBits.html#gacd64d9debbad763a7d5eec21757c53a6">AlgGrayCodeLL</a> (unsigned long long g)</td></tr>
<tr class="memdesc:gacd64d9debbad763a7d5eec21757c53a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Gray code of the given value.  <a href="#gacd64d9debbad763a7d5eec21757c53a6">More...</a><br /></td></tr>
<tr class="separator:gacd64d9debbad763a7d5eec21757c53a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga974b742e7a8df88a0e1aeedf12aa6c37"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AlgBits.html#ga974b742e7a8df88a0e1aeedf12aa6c37">AlgGrayCodeInv</a> (unsigned int g)</td></tr>
<tr class="memdesc:ga974b742e7a8df88a0e1aeedf12aa6c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse Gray code, ie the value corresponding to the given Gray code.  <a href="#ga974b742e7a8df88a0e1aeedf12aa6c37">More...</a><br /></td></tr>
<tr class="separator:ga974b742e7a8df88a0e1aeedf12aa6c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bf9522ea3a6c0b6b926fbc7cc228264"><td class="memItemLeft" align="right" valign="top">unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AlgBits.html#ga1bf9522ea3a6c0b6b926fbc7cc228264">AlgGrayCodeInvLL</a> (unsigned long long g)</td></tr>
<tr class="memdesc:ga1bf9522ea3a6c0b6b926fbc7cc228264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse Gray code, ie the value corresponding to the given Gray code.  <a href="#ga1bf9522ea3a6c0b6b926fbc7cc228264">More...</a><br /></td></tr>
<tr class="separator:ga1bf9522ea3a6c0b6b926fbc7cc228264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0debb01c87cefb685a2e0e15a3c82a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AlgBits.html#gab0debb01c87cefb685a2e0e15a3c82a0">AlgHilbertIndex</a> (unsigned int *h, unsigned int *p, int n, int o)</td></tr>
<tr class="memdesc:gab0debb01c87cefb685a2e0e15a3c82a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Hilbert index of a point in n dimensions.  <a href="#gab0debb01c87cefb685a2e0e15a3c82a0">More...</a><br /></td></tr>
<tr class="separator:gab0debb01c87cefb685a2e0e15a3c82a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10bff81a966352af2eea6ed4774f4739"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AlgBits.html#ga10bff81a966352af2eea6ed4774f4739">AlgHilbertIndexInv</a> (unsigned int *h, unsigned int *p, int n, int o)</td></tr>
<tr class="memdesc:ga10bff81a966352af2eea6ed4774f4739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the coordinates of the point in n dimensions corresponding to the given Hilbert index.  <a href="#ga10bff81a966352af2eea6ed4774f4739">More...</a><br /></td></tr>
<tr class="separator:ga10bff81a966352af2eea6ed4774f4739"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gac6ac7fe061b0232991f6e80feee60770"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int AlgBitSetCount </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>gMsk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of bits set in the given mask. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of bits set.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gMsk</td><td>Given bit mask. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacc49de29ecfaf88c38d8ac38685f3489"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AlgBitMostSigSet </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>gMsk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the most significant bit set in the given mask. The value returned will be zero if the mask was zero one if the mask had the value 1 or higher integer if the most significant bit set in the mask is greater. </p>
<dl class="section return"><dt>Returns</dt><dd>Most significant bit set in the given mask.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gMsk</td><td>Given bit mask. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group__WlzValuesUtils.html#ga65eaf55f82362941277e9136e0cd364f">WlzGreySetHilbertRankValues()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3fc0dc354e1452c16f585f885ec1fbab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AlgBitMostSigSetLL </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>gMsk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the most significant bit set in the given mask. The value returned will be zero if the mask was zero one if the mask had the value 1 or higher integer if the most significant bit set in the mask is greater. </p>
<dl class="section return"><dt>Returns</dt><dd>Most significant bit set in the given mask.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gMsk</td><td>Given bit mask. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6df7e43c1b23100ae4bac7baee7b144f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int AlgBitSetPositions </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>posA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>gMsk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of bits set in the given mask and sets the first elements of the given bit position array. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of bits set.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">posA</td><td>Bit set position array, MUST have a length &gt;= the number of bits in the unsigned long bit mask. </td></tr>
    <tr><td class="paramname">gMsk</td><td>Given bit mask. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae5b53afbdd516aefb22579add3a3229b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int AlgBitRotateRight </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates the given bit mask d places to the right (towards less significant bits) where there are n valid bits in the given bit mask. </p>
<dl class="section return"><dt>Returns</dt><dd>Bitmask rotated right.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Given bit mask. </td></tr>
    <tr><td class="paramname">n</td><td>Number of valid bits in the bit mask. </td></tr>
    <tr><td class="paramname">d</td><td>Number of places to rotate right. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8c6b306cc72a79139f38f2067c5893cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long AlgBitNextNOfM </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>curMsk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a bit mask which has n bits set and is &lt;= maxMsk, the new bit mask is the next after the given current mask. The maximum number of bits that can be stored in an unsigned long is assumed to be 32. If the actual number is less than this then this code won't work, if it's higher everything should be fine. This function can be used together with <a class="el" href="group__AlgBits.html#ga6df7e43c1b23100ae4bac7baee7b144f" title="Counts the number of bits set in the given mask and sets the first elements of the given bit position...">AlgBitSetPositions()</a> to select all ordered combinations of N of M. Eg to select all ordered combinations of 3 out of 5 this function would return 00111, 01011, 01101, 01110, 10110, 11010, 11100. </p>
<dl class="section return"><dt>Returns</dt><dd>Next bit mask for n bits, or zero on error.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curMsk</td><td>Current mask value. If the current value is zero then the first valid mask will be computed, otherwise the current mask is assumed to be valid. </td></tr>
    <tr><td class="paramname">n</td><td>Number of bits to be set. </td></tr>
    <tr><td class="paramname">m</td><td>Maximum number of bits to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga77608b0ea78e2f78d4378f8dbb11612f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AlgBitNextSet </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>msk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the index of the next bit set in the given mask using the index to the current bit as the start index. maxMsk, the new bit mask is the next after the given current mask. </p>
<dl class="section return"><dt>Returns</dt><dd>Index of the next bit set in the given mask, will be -ve if no next bit set.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msk</td><td>Given bit mask. </td></tr>
    <tr><td class="paramname">idC</td><td>Current bit index, -ve to find first bit set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf791bb557123dbe4daaf3d78a3518103"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AlgBitNextPowerOfTwo </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>dstP2I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>gI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the next integer that is &gt;= the given integer and has only a single bit set. </p>
<dl class="section return"><dt>Returns</dt><dd>Index of the single bit that should be set for an unsigned integer that's &gt;= the given int.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dstP2I</td><td>Destination ptr for integer that's &gt;= the given integer and is a power of two. </td></tr>
    <tr><td class="paramname">gI</td><td>Given integer. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="AlgAutoCorr_8c.html#af94dbbe51947644456256e5609971cae">AlgAutoCorrelate2D()</a>, <a class="el" href="group__AlgBits.html#gabd033ba78f6e9f06b0d2e83078918e1e">AlgBitIsPowerOfTwo()</a>, <a class="el" href="group__AlgCorr.html#gae6eb3e391d3c53a8a1cc1277b65cc272">AlgCrossCorrelate2D()</a>, <a class="el" href="group__WlzRegistration.html#ga28531f00a9abb735e1d8cb38b44a2057">WlzAutoCor()</a>, <a class="el" href="group__WlzFourier.html#ga796333a42d8cdbbccaad4b2c25c99c76">WlzFourierTransformObj()</a>, <a class="el" href="group__WlzDomainOps.html#ga372a93d29b9ef94a14735104a2c2975d">WlzLBTBalanceDomain2D()</a>, <a class="el" href="group__WlzDomainOps.html#gadfd3eec5397372409ed6dd5428d3a27c">WlzLBTBalanceDomain3D()</a>, <a class="el" href="group__WlzAllocation.html#ga26736f8f5c5492c341b555956980a7ae">WlzMakeLBTDomain2D()</a>, <a class="el" href="group__WlzAllocation.html#ga3bae1543bb050be3a397fbbc56adeaee">WlzMakeLBTDomain3D()</a>, <a class="el" href="group__WlzAllocation.html#ga387714099dc674a9995bd12100e3a788">WlzMakeTiledValuesObj2D()</a>, <a class="el" href="group__WlzAllocation.html#ga983c02e41cd3b395e6bf8efe8a5093fa">WlzMakeTiledValuesObj3D()</a>, and <a class="el" href="group__WlzRegistration.html#ga7e01176d73d148e49365076b59a81059">WlzRegCCorObjs()</a>.</p>

</div>
</div>
<a class="anchor" id="gabd033ba78f6e9f06b0d2e83078918e1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AlgBitIsPowerOfTwo </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>gI</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks that the given integer is an integral power of two. </p>
<dl class="section return"><dt>Returns</dt><dd>Non zero if the given integer is an integral power of two.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gI</td><td>Given integer. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group__AlgBits.html#gaf791bb557123dbe4daaf3d78a3518103">AlgBitNextPowerOfTwo()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7e0a13d3f7f814c1a81022676e4cca50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int AlgGrayCode </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Gray code of the given value. </p>
<dl class="section return"><dt>Returns</dt><dd>Gray code of the given integer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Given integer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacd64d9debbad763a7d5eec21757c53a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long AlgGrayCodeLL </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Gray code of the given value. </p>
<dl class="section return"><dt>Returns</dt><dd>Gray code of the given integer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Given long integer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga974b742e7a8df88a0e1aeedf12aa6c37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int AlgGrayCodeInv </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the inverse Gray code, ie the value corresponding to the given Gray code. </p>
<dl class="section return"><dt>Returns</dt><dd>Integer corresponding to the given Gray code.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Given Gray code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1bf9522ea3a6c0b6b926fbc7cc228264"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long AlgGrayCodeInvLL </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the inverse Gray code, ie the value corresponding to the given Gray code. </p>
<dl class="section return"><dt>Returns</dt><dd>Integer corresponding to the given Gray code.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Given Gray code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab0debb01c87cefb685a2e0e15a3c82a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AlgHilbertIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Hilbert index of a point in n dimensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hilbert index (set on return). </td></tr>
    <tr><td class="paramname">p</td><td>Position of the n dimensional point. </td></tr>
    <tr><td class="paramname">n</td><td>Number of dimensions. </td></tr>
    <tr><td class="paramname">o</td><td>Order (number of bits for coordinate). </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group__WlzValuesUtils.html#ga65eaf55f82362941277e9136e0cd364f">WlzGreySetHilbertRankValues()</a>.</p>

</div>
</div>
<a class="anchor" id="ga10bff81a966352af2eea6ed4774f4739"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AlgHilbertIndexInv </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the coordinates of the point in n dimensions corresponding to the given Hilbert index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>The given Hilbert index. </td></tr>
    <tr><td class="paramname">p</td><td>Decoded point coordinates (set on return). </td></tr>
    <tr><td class="paramname">n</td><td>Number of dimensions. </td></tr>
    <tr><td class="paramname">o</td><td>Order (number of bits for coordinate). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
